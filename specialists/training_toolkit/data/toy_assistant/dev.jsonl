{"prompt": "Fix this memory leak: setInterval(() => { fetchData(); }, 1000);", "completion": "Store the interval ID and clear it when component unmounts: const intervalId = setInterval(() => { fetchData(); }, 1000); return () => clearInterval(intervalId);"}
{"prompt": "Given [students(id, name, major_id), grades(student_id, course_id, grade)], find students with GPA above 3.5", "completion": "SELECT s.id, s.name, AVG(g.grade) as gpa FROM students s JOIN grades g ON s.id = g.student_id GROUP BY s.id, s.name HAVING AVG(g.grade) > 3.5 ORDER BY gpa DESC;"}
{"prompt": "Debug: def read_file(filename):\n    f = open(filename)\n    return f.read()", "completion": "File handle is never closed. Fix: Use context manager: def read_file(filename): with open(filename) as f: return f.read()"}
{"prompt": "Why doesn't this center the div? .container { margin: auto; }", "completion": "margin: auto only centers horizontally if width is set. Add: width: 80%; or use flexbox: display: flex; justify-content: center; align-items: center; on parent"}
{"prompt": "Write code to find the longest common prefix among array of strings", "completion": "def longest_common_prefix(strs):\n    if not strs:\n        return ''\n    prefix = strs[0]\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]\n            if not prefix:\n                return ''\n    return prefix"}
{"prompt": "Optimize: if len(my_list) == 0:", "completion": "More Pythonic and faster: if not my_list: - works for any empty sequence"}
{"prompt": "Given [videos(id, title, duration_seconds, upload_date), views(video_id, user_id, watch_time_seconds)], find videos with best completion rate", "completion": "SELECT v.id, v.title, COUNT(vw.user_id) as total_views, AVG(vw.watch_time_seconds * 100.0 / v.duration_seconds) as avg_completion_rate FROM videos v JOIN views vw ON v.id = vw.video_id GROUP BY v.id, v.title HAVING COUNT(vw.user_id) >= 100 ORDER BY avg_completion_rate DESC LIMIT 20;"}
{"prompt": "Debug: const data = { name: 'John', age: 30 }; console.log(data.address.city);", "completion": "Cannot read property 'city' of undefined. 'address' doesn't exist. Fix: Optional chaining: console.log(data.address?.city) or check: if (data.address) { console.log(data.address.city); }"}
{"prompt": "Write a function to implement LRU cache", "completion": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n    \n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)"}
{"prompt": "Given [flights(id, origin, destination, departure, arrival, price)], find cheapest route from A to B with max 1 stop", "completion": "SELECT f1.origin, f1.destination as stopover, f2.destination, f1.price + f2.price as total_price FROM flights f1 JOIN flights f2 ON f1.destination = f2.origin WHERE f1.origin = 'A' AND f2.destination = 'B' UNION SELECT origin, NULL, destination, price FROM flights WHERE origin = 'A' AND destination = 'B' ORDER BY total_price LIMIT 1;"}
{"prompt": "Debug: arr.filter(x => x > 5).map(x => x * 2).filter(x => x < 20)", "completion": "This works but chains multiple iterations. More efficient with reduce or single loop if performance matters: arr.reduce((acc, x) => { const val = x * 2; if (x > 5 && val < 20) acc.push(val); return acc; }, [])"}
{"prompt": "Why is my recursion slow? def fib(n): return fib(n-1) + fib(n-2) if n > 1 else n", "completion": "Exponential time complexity due to repeated calculations. Fix: Use memoization with @lru_cache decorator or dynamic programming"}
{"prompt": "Write code to detect cycle in linked list", "completion": "def has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False"}
{"prompt": "Given [campaigns(id, name, budget, start_date), conversions(campaign_id, timestamp, revenue)], calculate ROI per campaign", "completion": "SELECT c.id, c.name, c.budget, SUM(conv.revenue) as total_revenue, (SUM(conv.revenue) - c.budget) * 100.0 / c.budget as roi_percentage FROM campaigns c LEFT JOIN conversions conv ON c.id = conv.campaign_id GROUP BY c.id, c.name, c.budget ORDER BY roi_percentage DESC;"}
{"prompt": "Optimize: for i, item in enumerate(large_list):\n    if item == target:\n        return i\nreturn -1", "completion": "Use try/except with index(): try: return large_list.index(target); except ValueError: return -1"}
{"prompt": "Debug: @app.route('/user/<id>')\ndef get_user(id):\n    return User.query.get(id)", "completion": "id is string by default. If User.id is integer, convert: id = int(id) or specify type in route: @app.route('/user/<int:id>')"}
{"prompt": "Write a function to merge overlapping intervals", "completion": "def merge_intervals(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = [last[0], max(last[1], current[1])]\n        else:\n            merged.append(current)\n    return merged"}
{"prompt": "Given [posts(id, author_id, created), comments(post_id, user_id, created), users(id, username)], find most engaged posts by comment count", "completion": "SELECT p.id, u.username as author, COUNT(c.post_id) as comment_count FROM posts p JOIN users u ON p.author_id = u.id LEFT JOIN comments c ON p.id = c.post_id GROUP BY p.id, u.username ORDER BY comment_count DESC LIMIT 20;"}
{"prompt": "Debug: const promise = Promise.resolve(42);\npromise.then(console.log(result));", "completion": "Calling console.log immediately, not as callback. Fix: promise.then(result => console.log(result)) or simply: promise.then(console.log)"}
{"prompt": "Why doesn't DELETE CASCADE work? DELETE FROM users WHERE id = 1; -- foreign key constraint fails", "completion": "CASCADE not defined in foreign key constraint. When creating table: FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE"}
